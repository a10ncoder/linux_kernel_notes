# assembly language and how processor work

Assuming that segment descriptor for code, data, stack are stored in cs, ds and respectively ss registers.

**Instruction pointer**

1. value is in EIP register (RIP for 64 bits)
2. processor will execute an instruction stored in the address specified by the EIP
3. jump loc1 will change EIP to loc1


**Stack pointer for top address of the stack**

1. value is in ESP register (RSP for 64 bits)
2. push/pop instruction will store/get a value from an address specified by ESP and decrease/increase ESP by a corresponding size
3. stack grows from higher to lower memory address
4. Kernel can directly modify ESP during context switch


Stack base pointer for holding address of current stack frame, a range of stack holding passed parameters, return address and local parameters

1. value is in EBP register (RBP for 64 bits)
2. EBP contains address in stack where return address is stored.

call loc1 will push memory location after the instruction (EIP content) into current stack (memory location specified by ESP register) and jump to loc1.
ret will change EIP to a value in an address specified by ESP and increase ESP by a corresponding size

**AT&T assembly syntax**

example assembly code generated by hotspot jvm

          # {method} 'setA' '(I)V' in 'TestVolatile'
          # this:     ecx       = 'TestVolatile'
          # parm0:    edx       = int
          #           [sp+0x10]  (sp of caller)
          0xb4f48980: cmp    0x4(%ecx),%eax     ;...3b4104
          0xb4f48983: jne    0xb4f2cea0         ;...0f851745 feff
                                                ;   {runtime_call}
          0xb4f48989: xchg   %ax,%ax            ;...666690
        [Verified Entry Point]
          0xb4f4898c: push   %ebp               ;...55
          0xb4f4898d: sub    $0x8,%esp          ;...81ec0800 0000
          0xb4f48993: mov    %edx,0x8(%ecx)     ;...895108
          0xb4f48996: lock addl $0x0,(%esp)     ;...f0830424 00
                                                ;*synchronization entry
                                                ; - TestVolatile::setA@-1 (line 14)
          0xb4f4899b: add    $0x8,%esp          ;...83c408
          0xb4f4899e: pop    %ebp               ;...5d
          0xb4f4899f: test   %eax,0xb7f62000    ;...85050020 f6b7
                                                ;   {poll_return}
          0xb4f489a5: ret                       ;...c3
         

* register: %ax, %eax
* constant: $0x18, $0x4
* access memory location, its address is  in register: (%ecx), 0x4(%ecx)
* access memory location, its address is  in register + offset: 0x4(%ecx)
* move data from source (left operand) to destination (right operand): mov %edx,0x8(%ecx)


**References**

1. http://www.intel.com/Assets/PDF/manual/253665.pdf
2. http://sig9.com/articles/att-syntax
